<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>hash - C++ to Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">C++ to Rust</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="hash"><a class="header" href="#hash">hash</a></h1>
<h2 id="full-source-code"><a class="header" href="#full-source-code">Full source code</a></h2>
<p>C++</p>
<pre><code class="language-cpp">// -*- mode: c++ -*-
// $Id$
// http://www.bagley.org/~doug/shootout/

#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;ext/hash_map&gt;
#include &lt;cstring&gt;

using namespace std;
using namespace __gnu_cxx;

struct eqstr {
    bool operator()(const char* s1, const char* s2) const {
        return strcmp(s1, s2) == 0;
    }
};

int
main(int argc, char *argv[]) {
#ifdef SMALL_PROBLEM_SIZE
#define LENGTH 50000
#else
#define LENGTH 500000
#endif
    int n = ((argc == 2) ? atoi(argv[1]) : LENGTH);
    char buf[16];
    typedef __gnu_cxx::hash_map&lt;const char*, int, __gnu_cxx::hash&lt;const char*&gt;, eqstr&gt; HM;
    HM X;

    for (int i=1; i&lt;=n; i++) {
        sprintf(buf, "%x", i);
        X[strdup(buf)] = i;
    }

    int c = 0;
    for (int i=n; i&gt;0; i--) {
        sprintf(buf, "%d", i);
        if (X[strdup(buf)]) c++;
    }

    cout &lt;&lt; c &lt;&lt; endl;
}
</code></pre>
<p>Rust</p>
<pre><pre class="playground"><code class="language-rust">// Adapted from https://github.com/llvm/llvm-test-suite and
// http://www.bagley.org/~doug/shootout/
use std::env;
use std::collections::HashMap;

#[cfg(feature = "small_problem_size")]
const LENGTH: i32 = 50000;

#[cfg(not(feature = "small_problem_size"))]
const LENGTH: i32 = 500000;

fn main() {
    let mut args = env::args();
    let n = if args.len() == 2 {
        args.nth(1).unwrap().parse::&lt;i32&gt;().unwrap()
    } else {
        LENGTH
    };

    let mut x = HashMap::&lt;String, i32&gt;::new();

    for i in 1..=n {
        let s = format!("{:X}", i);
        x.insert(s, i);
    }

    let mut c: i32 = 0;
    for i in (1..=n).rev() {
        let s = format!("{}", i);
        if x.contains_key(&amp;s) {
            c += 1;
        }
    }

    println!("{}", c);
}</code></pre></pre>
<h2 id="porting-notes"><a class="header" href="#porting-notes">Porting notes</a></h2>
<h3 id="using-the-standard-string-and-hash-map-types"><a class="header" href="#using-the-standard-string-and-hash-map-types">Using the standard string and hash map types</a></h3>
<p>C++</p>
<pre><code class="language-cpp">    char buf[16];
    typedef __gnu_cxx::hash_map&lt;const char*, int, __gnu_cxx::hash&lt;const char*&gt;, eqstr&gt; HM;
    HM X;
</code></pre>
<p>Rust</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut x = HashMap::&lt;String, i32&gt;::new();
<span class="boring">}</span></code></pre></pre>
<p>The C++ version uses the C string <code>char*</code> and the GNU extension hash map <code>__gnu_cxx::hash_map</code> as opposed to <code>std::string</code> and <code>std::unordered_map</code>. I suspect that this program was originally written before the standard hash map became part of the C++ standard.</p>
<p>In the Rust version, we use the Rust standard <code>String</code> and <code>std::collections::HashMap</code> rather than more faithfully reproducing C string-like data structures or reimplementing the C++ <code>hash_map</code> in Rust to stick to the idiomatic Rust style.</p>
<p>There is no need to implement or pass the hash and the equal functions for the string type for the hash map in the Rust version, which would be equivalent to <code>__gnu_cxx::hash&lt;const char*&gt;</code> and <code>eqstr</code>, because they are provided by the standard library. This is also the case in <code>std::unordered_map</code> in C++.</p>
<h3 id="for-range-loops-with-the-inclusive-range-ends"><a class="header" href="#for-range-loops-with-the-inclusive-range-ends"><code>For</code> range loops with the inclusive range ends</a></h3>
<p>C++</p>
<pre><code class="language-cpp">    for (int i=1; i&lt;=n; i++) {
        ...
    }
    ...
    for (int i=n; i&gt;0; i--) {
        ...
    }
</code></pre>
<p>Rust</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    for i in 1..=n {
        ...
    }
    ...
    for i in (1..=n).rev() {
        ...
    }
<span class="boring">}</span></code></pre></pre>
<p>The <code>for</code> range loop <code>for i in 1..=n { ... }</code> has the range end <code>n</code> inclusive and is equivalent to <code>for (int i=1; i&lt;=n; i++) { ... }</code> in C++.</p>
<p>Similarly, the reverse ordered range loop <code>for i in (1..=n).rev() { ... }</code> is equivalent to <code>for (int i=n; i&gt;0; i--) { ... }</code> in C++.</p>
<h3 id="formating-strings"><a class="header" href="#formating-strings">Formating strings</a></h3>
<p>C++</p>
<pre><code class="language-cpp">        sprintf(buf, "%x", i);
</code></pre>
<p>Rust</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        let s = format!("{:X}", i);
<span class="boring">}</span></code></pre></pre>
<p>A common way to format a string in Rust is to use <code>format!</code> roughly corresponding to <code>sprintf</code> in C++.</p>
<p>While the C++ version writes into an already allocated buffer, the Rust version allocates a new string. This could significantly affect the performance difference but it will be roughly canceled out by the fact that the C++ version will copy the key when inserting the key into hash map in the next line.</p>
<h3 id="inserting-into-a-hash-map"><a class="header" href="#inserting-into-a-hash-map">Inserting into a hash map</a></h3>
<p>C++</p>
<pre><code class="language-cpp">        X[strdup(buf)] = i;
</code></pre>
<p>Rust</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        x.insert(s, i);
<span class="boring">}</span></code></pre></pre>
<p>Rust <code>HashMap</code> has the square bracket operator <code>[]</code> but it will panic if the key already exists, unlike the C++ hash map. So we use <code>insert</code> instead.</p>
<h3 id="checking-whether-an-hash-map-already-contains-a-key"><a class="header" href="#checking-whether-an-hash-map-already-contains-a-key">Checking whether an hash map already contains a key</a></h3>
<p>C++</p>
<pre><code class="language-cpp">        if (X[strdup(buf)]) c++;
</code></pre>
<p>Rust</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        if x.contains_key(&amp;s) {
            c += 1;
        }
<span class="boring">}</span></code></pre></pre>
<p>There is a subtle difference that the C++ version inserts a new entry with the default value <code>0</code> when the key is not already contained in the hash map, in addition to checking whether the key is already contained, while the Rust version only checks if the key is already contained, again, because Rust <code>HashMap</code>'s <code>[]</code> operator will panic if the key does not already exist in the hash map.</p>
<p>This difference is absorbed by the fact that value <code>0</code> is not used across the two loops and the two if statements branch the same way.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../programs/fibo.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../programs/hash2.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../programs/fibo.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../programs/hash2.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
