<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>matrix - C++ to Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">C++ to Rust</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="matrix"><a class="header" href="#matrix">matrix</a></h1>
<h2 id="full-source-code"><a class="header" href="#full-source-code">Full source code</a></h2>
<p>C++</p>
<pre><code class="language-cpp">// -*- mode: c++ -*-
// $Id$
// http://www.bagley.org/~doug/shootout/

#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;

using namespace std;

#define SIZE 30

int **mkmatrix(int rows, int cols) {
    int i, j, count = 1;
    int **m = (int **) malloc(rows * sizeof(int *));
    for (i=0; i&lt;rows; i++) {
        m[i] = (int *) malloc(cols * sizeof(int));
        for (j=0; j&lt;cols; j++) {
            m[i][j] = count++;
        }
    }
    return(m);
}

void zeromatrix(int rows, int cols, int **m) {
    int i, j;
    for (i=0; i&lt;rows; i++)
        for (j=0; j&lt;cols; j++)
            m[i][j] = 0;
}

void freematrix(int rows, int **m) {
    while (--rows &gt; -1) { free(m[rows]); }
    free(m);
}

int **mmult(int rows, int cols, int **m1, int **m2, int **m3) {
    int i, j, k, val;
    for (i=0; i&lt;rows; i++) {
        for (j=0; j&lt;cols; j++) {
            val = 0;
            for (k=0; k&lt;cols; k++) {
                val += m1[i][k] * m2[k][j];
            }
            m3[i][j] = val;
        }
    }
    return(m3);
}

int main(int argc, char *argv[]) {
#ifdef SMALL_PROBLEM_SIZE
#define LENGTH 10000
#else
#define LENGTH 100000
#endif
    int i, n = ((argc == 2) ? atoi(argv[1]) : LENGTH);

    int **m1 = mkmatrix(SIZE, SIZE);
    int **m2 = mkmatrix(SIZE, SIZE);
    int **mm = mkmatrix(SIZE, SIZE);

    for (i=0; i&lt;n; i++) {
        mm = mmult(SIZE, SIZE, m1, m2, mm);
    }
    cout &lt;&lt; mm[0][0] &lt;&lt; " " &lt;&lt; mm[2][3] &lt;&lt; " " &lt;&lt; mm[3][2] &lt;&lt; " " &lt;&lt; mm[4][4] &lt;&lt; endl;

    freematrix(SIZE, m1);
    freematrix(SIZE, m2);
    freematrix(SIZE, mm);
    return(0);
}
</code></pre>
<p>Rust</p>
<pre><pre class="playground"><code class="language-rust">// Adapted from https://github.com/llvm/llvm-test-suite and
// http://www.bagley.org/~doug/shootout/
use std::env;

const SIZE: usize = 30;

#[cfg(feature = "small_problem_size")]
const LENGTH: i32 = 10000;

#[cfg(not(feature = "small_problem_size"))]
const LENGTH: i32 = 100000;

fn mkmatrix(rows: usize, cols: usize) -&gt; Vec::&lt;Vec::&lt;i32&gt;&gt; {
    let mut count = 1;
    let mut m = Vec::&lt;Vec::&lt;i32&gt;&gt;::new();
    m.resize(rows, Default::default());
    for i in 0..rows {
        m[i].resize(cols, Default::default());
        for j in 0..cols {
            m[i][j] = count;
            count += 1;
        }
    }
    return m;
}

fn mmult(rows: usize, cols: usize, m1: &amp;Vec::&lt;Vec::&lt;i32&gt;&gt;,
         m2: &amp;Vec::&lt;Vec::&lt;i32&gt;&gt;, m3: &amp;mut Vec::&lt;Vec::&lt;i32&gt;&gt;) {
    for i in 0..rows {
        for j in 0..cols {
            let mut val = 0;
            for k in 0..cols {
                val += m1[i][k] * m2[k][j];
            }
            m3[i][j] = val;
        }
    }
}

fn main() {
    let mut args = env::args();
    let n = if args.len() == 2 {
        args.nth(1).unwrap().parse::&lt;i32&gt;().unwrap()
    } else {
        LENGTH
    };

    let m1 = mkmatrix(SIZE, SIZE);
    let m2 = mkmatrix(SIZE, SIZE);
    let mut mm = mkmatrix(SIZE, SIZE);

    for _i in 0..n {
        mmult(SIZE, SIZE, &amp;m1, &amp;m2, &amp;mut mm);
    }
    println!("{} {} {} {}", mm[0][0], mm[2][3], mm[3][2], mm[4][4]);
}</code></pre></pre>
<h2 id="porting-notes"><a class="header" href="#porting-notes">Porting notes</a></h2>
<h3 id="using-nested-vecs-to-represent-a-matrix"><a class="header" href="#using-nested-vecs-to-represent-a-matrix">Using nested <code>Vec</code>s to represent a matrix</a></h3>
<p>C++</p>
<pre><code class="language-cpp">int **mkmatrix(int rows, int cols) {
    int i, j, count = 1;
    int **m = (int **) malloc(rows * sizeof(int *));
    for (i=0; i&lt;rows; i++) {
        m[i] = (int *) malloc(cols * sizeof(int));
        for (j=0; j&lt;cols; j++) {
            m[i][j] = count++;
        }
    }
    return(m);
}
</code></pre>
<p>Rust</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn mkmatrix(rows: usize, cols: usize) -&gt; Vec::&lt;Vec::&lt;i32&gt;&gt; {
    let mut count = 1;
    let mut m = Vec::&lt;Vec::&lt;i32&gt;&gt;::new();
    m.resize(rows, Default::default());
    for i in 0..rows {
        m[i].resize(cols, Default::default());
        for j in 0..cols {
            m[i][j] = count;
            count += 1;
        }
    }
    return m;
}
<span class="boring">}</span></code></pre></pre>
<p>We use a two-level, nested <code>Vec</code> data structure where the first level is for the rows and the second level is for the columns. That is similar to the data structure that uses arrays in the C++ version. While it'd be possible to use raw i32 arrays in Rust, it is more idiomatic to use <code>Vec</code> treating <code>Vec</code> as the safe equivalent of raw arrays.</p>
<h3 id="passing-matrices-to-the-matrix-multiplication-function-using-references"><a class="header" href="#passing-matrices-to-the-matrix-multiplication-function-using-references">Passing matrices to the matrix multiplication function using references</a></h3>
<p>C++</p>
<pre><code class="language-cpp">    int **m1 = mkmatrix(SIZE, SIZE);
    int **m2 = mkmatrix(SIZE, SIZE);
    int **mm = mkmatrix(SIZE, SIZE);

    for (i=0; i&lt;n; i++) {
        mm = mmult(SIZE, SIZE, m1, m2, mm);
    }
</code></pre>
<p>Rust</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let m1 = mkmatrix(SIZE, SIZE);
    let m2 = mkmatrix(SIZE, SIZE);
    let mut mm = mkmatrix(SIZE, SIZE);

    for _i in 0..n {
        mmult(SIZE, SIZE, &amp;m1, &amp;m2, &amp;mut mm);
    }
<span class="boring">}</span></code></pre></pre>
<h3 id="freeing-matrices"><a class="header" href="#freeing-matrices">Freeing matrices</a></h3>
<p>C++</p>
<pre><code class="language-cpp">    freematrix(SIZE, m1);
    freematrix(SIZE, m2);
    freematrix(SIZE, mm);
</code></pre>
<p>Rust</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// empty
<span class="boring">}</span></code></pre></pre>
<p>The Rust version doesn't need to explicitly free the matrices because they are automatically dropped at the end of the main function thanks to the ownership mechanism.</p>
<h2 id="performance-analysis"><a class="header" href="#performance-analysis">Performance analysis</a></h2>
<p><a href="../benchmarking-results.html">The benchmark results</a> show that the Rust version is more than 2 times slower than the C++ version.</p>
<p>We compare the generated code between C++ and Rust.</p>
<h3 id="c"><a class="header" href="#c">C++</a></h3>
<p>Here is the hot loop according to the Linux Perf:</p>
<p>C++ perfdata</p>
<pre><code>  5.98 │2b0:   mov    -0x10(%r14,%r8,8),%r10
  5.93 │       mov    -0x8(%r14,%r8,8),%r11
  7.04 │       mov    (%r10,%rdi,4),%r10d
 11.66 │       imul   -0x8(%rsi,%r8,4),%r10d
  5.84 │       add    %r9d,%r10d
  5.71 │       mov    (%r11,%rdi,4),%r11d
 10.56 │       imul   -0x4(%rsi,%r8,4),%r11d
 11.00 │       mov    (%r14,%r8,8),%r9
  5.17 │       mov    (%r9,%rdi,4),%r9d
  4.77 │       imul   (%rsi,%r8,4),%r9d
  4.52 │       add    %r11d,%r9d
  4.53 │       add    %r10d,%r9d
  8.94 │       add    $0x3,%r8
  4.73 │       cmp    $0x20,%r8
       │     ↑ jne    2b0
</code></pre>
<p>C++ LLVM IR</p>
<pre><code>106:                                              ; preds = %106, %104
  %107 = phi i64 [ 0, %104 ], [ %135, %106 ]
  %108 = phi i32 [ 0, %104 ], [ %134, %106 ]
  %109 = getelementptr inbounds nuw i32, ptr %103, i64 %107
  %110 = load i32, ptr %109, align 4, !tbaa !10
  %111 = getelementptr inbounds nuw ptr, ptr %39, i64 %107
  %112 = load ptr, ptr %111, align 8, !tbaa !5
  %113 = getelementptr inbounds nuw i32, ptr %112, i64 %105
  %114 = load i32, ptr %113, align 4, !tbaa !10
  %115 = mul nsw i32 %114, %110
  %116 = add nsw i32 %115, %108
  %117 = add nuw nsw i64 %107, 1
  %118 = getelementptr inbounds nuw i32, ptr %103, i64 %117
  %119 = load i32, ptr %118, align 4, !tbaa !10
  %120 = getelementptr inbounds nuw ptr, ptr %39, i64 %117
  %121 = load ptr, ptr %120, align 8, !tbaa !5
  %122 = getelementptr inbounds nuw i32, ptr %121, i64 %105
  %123 = load i32, ptr %122, align 4, !tbaa !10
  %124 = mul nsw i32 %123, %119
  %125 = add nsw i32 %124, %116
  %126 = add nuw nsw i64 %107, 2
  %127 = getelementptr inbounds nuw i32, ptr %103, i64 %126
  %128 = load i32, ptr %127, align 4, !tbaa !10
  %129 = getelementptr inbounds nuw ptr, ptr %39, i64 %126
  %130 = load ptr, ptr %129, align 8, !tbaa !5
  %131 = getelementptr inbounds nuw i32, ptr %130, i64 %105
  %132 = load i32, ptr %131, align 4, !tbaa !10
  %133 = mul nsw i32 %132, %128
  %134 = add nsw i32 %133, %125
  %135 = add nuw nsw i64 %107, 3
  %136 = icmp eq i64 %135, 30
  br i1 %136, label %137, label %106, !llvm.loop !22
</code></pre>
<p>The loop is unrolled by a factor of 3.</p>
<h3 id="rust"><a class="header" href="#rust">Rust</a></h3>
<p>Here is the hot loop according to the Linux Perf:</p>
<p>Rust perfdata</p>
<pre><code> 16.54 │ 260:   cmp    %rbx,%rsi
       │      ↓ je     5c3
  5.16 │        cmp    %rbx,%r8
       │      ↓ je     5d2
  4.99 │        mov    (%r12),%r13
  4.84 │        cmp    %r13,%rdi
       │      ↓ jae    5e1
 10.44 │        mov    0x8(%rax),%r13
  5.67 │        mov    0x0(%r13,%rbx,4),%r13d
  5.73 │        mov    -0x8(%r12),%r14
  5.16 │        imul   (%r14,%rdi,4),%r13d
  5.51 │        inc    %rbx
 10.59 │        add    %r13d,%r9d
  5.17 │        add    $0x18,%r12
 17.06 │        cmp    $0x1e,%rbx
       │      ↑ jne    260
</code></pre>
<p>Rust LLVM IR</p>
<pre><code>bb10.us.i:                                        ; preds = %bb17.us.i, %bb7.us.i
  %iter2.sroa.0.024.us.i = phi i64 [ 0, %bb7.us.i ], [ %_0.i13.us.i, %bb17.us.i ]
  %val.sroa.0.023.us.i = phi i32 [ 0, %bb7.us.i ], [ %95, %bb17.us.i ]
  %_0.i13.us.i = add nuw nsw i64 %iter2.sroa.0.024.us.i, 1
  %exitcond.not.i = icmp eq i64 %iter2.sroa.0.024.us.i, %_47.us.i
  br i1 %exitcond.not.i, label %panic7.i.invoke, label %bb15.us.i

bb15.us.i:                                        ; preds = %bb10.us.i
  %_48.us.i = load ptr, ptr %90, align 8, !nonnull !4, !noundef !4
  %_15.us.i = getelementptr inbounds i32, ptr %_48.us.i, i64 %iter2.sroa.0.024.us.i
  %_14.us.i = load i32, ptr %_15.us.i, align 4, !noundef !4
  %exitcond89.not.i = icmp eq i64 %iter2.sroa.0.024.us.i, %m2.val25
  br i1 %exitcond89.not.i, label %panic7.i.invoke, label %bb16.us.i

bb16.us.i:                                        ; preds = %bb15.us.i
  call void @llvm.assume(i1 %35)
  %_19.us.i = getelementptr inbounds %"alloc::vec::Vec&lt;i32&gt;", ptr %m2.val, i64 %iter2.sroa.0.024.us.i
  %93 = getelementptr inbounds i8, ptr %_19.us.i, i64 16
  %_57.us.i = load i64, ptr %93, align 8, !noundef !4
  %_60.us.i = icmp ult i64 %iter1.sroa.0.025.us.i, %_57.us.i
  br i1 %_60.us.i, label %bb17.us.i, label %panic7.i.invoke

bb17.us.i:                                        ; preds = %bb16.us.i
  %94 = getelementptr inbounds i8, ptr %_19.us.i, i64 8
  %_58.us.i = load ptr, ptr %94, align 8, !nonnull !4, !noundef !4
  %_18.us.i = getelementptr inbounds i32, ptr %_58.us.i, i64 %iter1.sroa.0.025.us.i
  %_17.us.i = load i32, ptr %_18.us.i, align 4, !noundef !4
  %_13.us.i = mul i32 %_17.us.i, %_14.us.i
  %95 = add i32 %_13.us.i, %val.sroa.0.023.us.i
  %exitcond90.not.i = icmp eq i64 %_0.i13.us.i, 30
  br i1 %exitcond90.not.i, label %bb12.us.i, label %bb10.us.i
</code></pre>
<p>The key differences from the C++ version are the following.</p>
<p>First, the <code>mmult</code> function isn't inlined into the main function. That makes it non-trivial to constant-propgate the <code>Vec</code> sizes as compile-time constant 30. If intraprocedural constant propagation was implemented indepedent of inlining, it would do but it doesn't seem to be there.</p>
<p>Second, the bounds checks are not elided. The bounds checks could be hoisted out of the loop (loop invariant code motion) and the special-cased, bounds-check-free version of the innermost loop could be generated (loop versioning). The LLVM backend probably has some form of these implemented but it doesn't seem to trigger here.</p>
<p>Third, loop unrolling has not been applied. I suspect that because of the above two lack of optimizations, the loop doesn't look simple enough for loop unrolling to kick in.</p>
<p>Note these are differences in the frontends. The Clang frontend applied these three optimiations for the C++ version. But the Rustc frontend did not for the Rust version. While the LLVM backend could also apply these in theory but it doesn't seem to at least in the given environment.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../programs/lists1.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../programs/methcall.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../programs/lists1.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../programs/methcall.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
